From 29432aaf51aeaf46c75ddc2372bc3f5c344c00c1 Mon Sep 17 00:00:00 2001
From: Lukas Larsson <lukas@erlang.org>
Date: Tue, 29 Oct 2019 15:45:47 +0100
Subject: [PATCH 4/6] erts: Optimize deferred save message queue pointer

In 765fa3285ef a bug fix for the message queue receive
optimization made the optimization not take when the
internal message queue was empty and the save mark was
in the middle queue.

With this commit we move that decision into a flags instead
so we now can know when to restore the save pointer when
messages are moved from the middle to internal queue.
---
 erts/emulator/beam/erl_message.h        |  7 +-
 erts/emulator/beam/erl_proc_sig_queue.c | 18 ++---
 erts/emulator/beam/erl_process.h        |  1 +
 erts/emulator/test/receive_SUITE.erl    | 91 ++++++++++++++++++++++++-
 erts/etc/unix/etp-commands.in           |  3 +
 5 files changed, 98 insertions(+), 22 deletions(-)

diff --git a/erts/emulator/beam/erl_message.h b/erts/emulator/beam/erl_message.h
index 3949396d60..40847d5945 100644
--- a/erts/emulator/beam/erl_message.h
+++ b/erts/emulator/beam/erl_message.h
@@ -338,10 +338,7 @@ typedef struct erl_trace_message_queue__ {
     do {                                                                \
         if ((P)->sig_qs.saved_last) {                                   \
             if ((P)->sig_qs.flags & FS_DEFERRED_SAVED_LAST) {           \
-                /* Points to middle queue; use end of inner */          \
-                /* This is later used by erts_proc_sig_handle_incoming */\
-                /* to set the save to the correct place */              \
-                (P)->sig_qs.save = (P)->sig_qs.last;                    \
+                (P)->sig_qs.flags |= FS_DEFERRED_SAVE;                  \
                 ASSERT(!PEEK_MESSAGE((P)));                             \
             }                                                           \
             else {                                                      \
@@ -354,7 +351,7 @@ typedef struct erl_trace_message_queue__ {
 #define ERTS_RECV_MARK_CLEAR(P)                                         \
     do {                                                                \
         (P)->sig_qs.saved_last = NULL;                                  \
-        (P)->sig_qs.flags &= ~FS_DEFERRED_SAVED_LAST;                   \
+        (P)->sig_qs.flags &= ~(FS_DEFERRED_SAVED_LAST|FS_DEFERRED_SAVE); \
     } while (0)
 
 
diff --git a/erts/emulator/beam/erl_proc_sig_queue.c b/erts/emulator/beam/erl_proc_sig_queue.c
index e236646005..2347527e28 100644
--- a/erts/emulator/beam/erl_proc_sig_queue.c
+++ b/erts/emulator/beam/erl_proc_sig_queue.c
@@ -3597,7 +3597,7 @@ stop: {
         int deferred_save, deferred_saved_last, res;
 
         deferred_saved_last = !!(c_p->sig_qs.flags & FS_DEFERRED_SAVED_LAST);
-        deferred_save = 0;
+        deferred_save = !!(c_p->sig_qs.flags & FS_DEFERRED_SAVE);
 
         if (!deferred_saved_last)
             deferred_save = 0;
@@ -3607,21 +3607,11 @@ stop: {
                 c_p->sig_qs.flags &= ~FS_DEFERRED_SAVED_LAST;
                 deferred_saved_last = deferred_save = 0;
             }
-            else {
-                if (c_p->sig_qs.save == c_p->sig_qs.last &&
-                    c_p->sig_qs.save != &c_p->sig_qs.first)
-                    /* When save is set to last AND DEFERRED_SAVED_LAST is
-                       set we know that we have done a ERTS_RECV_MARK_SET
-                       to the last in order to trigger a clean of the middle
-                       queue. However, we cannot know this when there
-                       are no messages in the inner queue, so in that
-                       case we have to parse the entire queue again */
-                    deferred_save = !0;
-                else
-                    deferred_save = 0;
-            }
         }
 
+        if (deferred_save)
+            c_p->sig_qs.flags &= ~FS_DEFERRED_SAVE;
+
         ASSERT(c_p->sig_qs.saved_last != &c_p->sig_qs.cont);
 
         if (ERTS_UNLIKELY(msg_tracing != 0)) {
diff --git a/erts/emulator/beam/erl_process.h b/erts/emulator/beam/erl_process.h
index eb54df41c2..41f8ac0762 100644
--- a/erts/emulator/beam/erl_process.h
+++ b/erts/emulator/beam/erl_process.h
@@ -1442,6 +1442,7 @@ extern int erts_system_profile_ts_type;
 #define FS_OFF_HEAP_MSGQ_CHNG  (1 << 2) /* Off heap msg queue changing */
 #define FS_LOCAL_SIGS_ONLY     (1 << 3) /* Handle privq sigs only */
 #define FS_DEFERRED_SAVED_LAST (1 << 4) /* Deferred sig_qs.saved_last */
+#define FS_DEFERRED_SAVE       (1 << 5) /* Deferred sig_qs.save */
 #define FS_DELAYED_PSIGQS_LEN  (1 << 6) /* Delayed update of sig_qs.len */
 #define FS_HIPE_RECV_LOCKED    (1 << 7) /* HiPE message queue locked */
 #define FS_HIPE_RECV_YIELD     (1 << 8) /* HiPE receive yield */
diff --git a/erts/emulator/test/receive_SUITE.erl b/erts/emulator/test/receive_SUITE.erl
index 1fe11428b4..4f24ecccb7 100644
--- a/erts/emulator/test/receive_SUITE.erl
+++ b/erts/emulator/test/receive_SUITE.erl
@@ -26,15 +26,19 @@
 
 -export([all/0, suite/0,
 	 call_with_huge_message_queue/1,receive_in_between/1,
-         receive_opt_exception/1,receive_opt_recursion/1]).
+         receive_opt_exception/1,receive_opt_recursion/1,
+         receive_opt_deferred_save/1]).
 
 suite() ->
     [{ct_hooks,[ts_install_cth]},
      {timetrap, {minutes, 3}}].
 
 all() ->
-    [call_with_huge_message_queue, receive_in_between,
-     receive_opt_exception, receive_opt_recursion].
+    [call_with_huge_message_queue,
+     receive_in_between,
+     receive_opt_exception,
+     receive_opt_recursion,
+     receive_opt_deferred_save].
 
 call_with_huge_message_queue(Config) when is_list(Config) ->
     Pid = spawn_link(fun echo_loop/0),
@@ -169,6 +173,87 @@ do_receive_opt_recursion(Recipient, Disturber, IsInner) ->
             end
     end.
 
+
+%% Test that the receive opt behaves correctly when
+%% the messages are in the middle queue. It only triggers
+%% a very special scenario that OTP-16241 solves.
+receive_opt_deferred_save(_Config) ->
+
+    erts_debug:set_internal_state(available_internal_state, true),
+
+    %% This testcase is very very white-boxy, but I'm not
+    %% sure what to do about that.
+
+    Pid = spawn_opt(fun() ->
+                        deferred()
+                end,[{scheduler, 2}]),
+    spawn_opt(fun() ->
+                      link(Pid),
+                      Lst = lists:seq(1,200),
+                      Pid ! go,
+                      %% Sleep in order to make sure that Pid gets
+                      %% scheduled in.
+                      erts_debug:set_internal_state(sleep, 250),
+                      Ref = erlang:monitor(process, Pid),
+                      [Pid ! I || I <- Lst],
+                      Pid ! stop,
+                      receive
+                          {'DOWN', Ref, process, Pid, normal} ->
+                              ok
+                      after 2000 ->
+                              exit(stop_timeout)
+                      end
+              end,[{scheduler,1},monitor]),
+    receive
+        {'DOWN',_, process, _, normal} ->
+            ok;
+        {'DOWN',_, process, _, Reason} ->
+            ct:fail(Reason)
+    end.
+
+deferred() ->
+    receive
+        go ->
+            %% Sleep for a while so that the middle queue
+            %% is filled
+            erts_debug:set_internal_state(sleep, 1000)
+    end,
+
+    %% Here the inner queue should be empty and the middle queue
+    %% should have 200 messages and one monitor signal.
+    %% The monitor signal is important as otherwise all messages
+    %% will just be moved from the outer to the inner queue
+    %% immediately.
+
+    %% Setup the receive opt mark
+    %% This receive opt is as of PR-2439 disabled, though future
+    %% optimizations may enable it again....
+    Ref = make_ref(),
+    self() ! Ref,
+
+    %% Call another function that does a non-receive opt receive.
+    %% Before OTP-16241 this would hang as the save marker in the
+    %% message queue would be incorrectly set.
+    deferred(1,200),
+
+    %% Get the ref using receive opt here.
+    receive
+        Ref ->
+            ok
+    end,
+    receive
+        stop ->
+            erlang:display(ok)
+    end.
+
+deferred(N,M) when N > M ->
+    ok;
+deferred(N,M) ->
+    receive
+        N ->
+            deferred(N+1,M)
+    end.
+
 %%%
 %%% Common helpers.
 %%%
diff --git a/erts/etc/unix/etp-commands.in b/erts/etc/unix/etp-commands.in
index 88291b9d31..68666e36f0 100644
--- a/erts/etc/unix/etp-commands.in
+++ b/erts/etc/unix/etp-commands.in
@@ -1374,6 +1374,9 @@ define etp-sigq-flags-int
   if ($arg0 & (1 << 6))
     printf "delayed-sigq-len "
   end
+  if ($arg0 & (1 << 5))
+    printf "deferred-save "
+  end
   if ($arg0 & (1 << 4))
     printf "deferred-saved-last "
   end
-- 
2.20.1

